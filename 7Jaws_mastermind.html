Challenge: The shark tracker is protected by a MasterMind-style code lock.
The secret code is a sequence of 4 digits (0-9). You have to break it by writing
a Python script that guesses the code automatically. If we don't find the correct
code within 5000 tries we'll be locked out.
<p>
Rules:
<ul>
    <li>After each guess, the system returns a history of:</li>
    <ul>
        <li>last guess</li>
        <li>Correct positions: number of digits guessed exactly.</li>
        <li>Correct digits (wrong position): number of correct digits in wrong place.</li>
        <li>Example history: [([0,0,0,0], (2,0)), ([0,0,1,1], (3,0)), ([0,0,1,6], (3,0))]</li>
    </ul>
    <li>Keep guessing until you crack the code.</li>
</ul>
</p>

Task:
<ol>
    <li>Write Python code that plays MasterMind until it finds the code.</li>
    <li>Enter the correct code when prompted.</li>
</ol>
<textarea id="editor" style="width:100%;height:700px;background-color: black; color: lime;">
def mastermind_guesser(history):
    guess = [0,0,0,0]
    #your code here
    return guess

# Test case don't type below this
run_selected_test()
</textarea>

<button onclick="runCode()" style="margin-top:10px;">Run Unit Tests</button>

<textarea id="output" style="width:100%;height:100px;border:1px solid #ccc;overflow-y:auto;padding:10px;margin-top:10px;background-color: black; color: lime;">
    Output or flag will appear here...
</textarea>

<script src="https://cdn.jsdelivr.net/pyodide/v0.22.1/full/pyodide.js"></script>
<script>
    async function runCode() {
        const editor = document.getElementById("editor").value;
        const output = document.getElementById("output");
        if (editor.includes("import os") || editor.includes("import shutil")) {
            output.innerHTML = "ERROR: Usage of 'import os' and 'import shutil' are not allowed";
            return;
        }

        output.innerHTML = "Running...";

        try {
            // Load Pyodide and initialize it
            const pyodide = await loadPyodide();

            // Preload the test infrastructure
            pyodide.runPython(`
import sys
import unittest
from io import StringIO
from unittest.mock import patch
import itertools
import random

sys.stdout = StringIO()
sys.stderr = StringIO()

def feedback(guess, secret):
    """(cp, cd) for MasterMind with digits 0..9, length 4."""
    cp = sum(1 for i in range(4) if guess[i] == secret[i])
    cd = sum(min(guess.count(d), secret.count(d)) for d in set(guess)) - cp
    return cp, cd

def candidates_consistent_with(history):
    """Return all codes consistent with the provided history."""
    all_codes = itertools.product(range(10), repeat=4)
    res = []
    for c in all_codes:
        if all(feedback(g, c) == (cp, cd) for g, (cp, cd) in history):
            res.append(list(c))
    return res

def is_valid_guess(g):
    return (
        isinstance(g, (list, tuple)) and
        len(g) == 4 and
        all(isinstance(d, int) and 0 <= d <= 9 for d in g)
    )

def run_selected_test():
    class TestPyNight(unittest.TestCase):
        @patch("sys.stdout", new_callable=StringIO)
        def test_returns_valid_and_silent_on_empty_history(self, mock_stdout):
            guess = mastermind_guesser(history=[])
            self.assertTrue(is_valid_guess(guess))
            self.assertEqual(mock_stdout.getvalue(), "")
            if hasattr(mastermind_guesser, "_all"):
                delattr(mastermind_guesser, "_all")

        @patch("sys.stdout", new_callable=StringIO)
        def test_guess_is_consistent_with_history(self, mock_stdout):
            history = [([0,0,0,0], (1,0)), ([0,1,1,1], (2,0))]
            guess = mastermind_guesser(history)
            self.assertTrue(is_valid_guess(guess))
            for prev_guess, (cp, cd) in history:
                self.assertEqual(feedback(prev_guess, guess), (cp, cd))
            self.assertEqual(mock_stdout.getvalue(), "")
            if hasattr(mastermind_guesser, "_all"):
                delattr(mastermind_guesser, "_all")

        @patch("sys.stdout", new_callable=StringIO)
        def test_unique_candidate_must_be_returned(self, mock_stdout):
            secret = [3,1,4,1]
            history = []
            for g in ([0,0,0,0], [1,1,1,1], [3,1,4,1]):
                history.append((g, feedback(g, secret)))
            cands = candidates_consistent_with(history)
            self.assertEqual(len(cands), 1)
            guess = mastermind_guesser(history)
            self.assertEqual(guess, cands[0])
            self.assertEqual(mock_stdout.getvalue(), "")
            if hasattr(mastermind_guesser, "_all"):
                delattr(mastermind_guesser, "_all")

        @patch("sys.stdout", new_callable=StringIO)
        def test_different_histories_lead_to_different_outputs(self, mock_stdout):
            h1 = [([0,0,0,0], (0,0))]
            h2 = [([0,0,0,0], (4,0))]
            g1 = mastermind_guesser(h1)
            g2 = mastermind_guesser(h2)
            self.assertTrue(is_valid_guess(g1))
            self.assertTrue(is_valid_guess(g2))
            self.assertNotEqual(g1, g2)
            self.assertEqual(mock_stdout.getvalue(), "")
            if hasattr(mastermind_guesser, "_all"):
                delattr(mastermind_guesser, "_all")

    # Run the tests
    suite = unittest.TestSuite()
    suite.addTest(TestPyNight("test_returns_valid_and_silent_on_empty_history"))
    suite.addTest(TestPyNight("test_guess_is_consistent_with_history"))
    suite.addTest(TestPyNight("test_unique_candidate_must_be_returned"))
    suite.addTest(TestPyNight("test_different_histories_lead_to_different_outputs"))
    success_message = "Correct the flag is: JAWS{we're_gonna_need_a_bigger_code}"
    runner = unittest.TextTestRunner(resultclass=CustomTestResult)
    result = runner.run(suite)
    if result.wasSuccessful():
        print(success_message)
class CustomTestResult(unittest.TextTestResult):
    def addSuccess(self, test):
        pass
`);

            // Execute the user's Python code
            pyodide.runPython(editor);

            // Retrieve the results
            const stdout = pyodide.runPython("sys.stdout.getvalue()");
            const stderr = pyodide.runPython("sys.stderr.getvalue()");

            // Display results
            output.innerHTML = stdout || stderr || "No output.";
        } catch (error) {
            output.innerHTML = `Error: ${error}`;
        }
    }
</script>